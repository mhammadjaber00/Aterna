-- io.yavero.aterna.data.database.QuestLog.sq

CREATE TABLE QuestLogEntity (
  id TEXT NOT NULL PRIMARY KEY,
  heroId TEXT NOT NULL,
  durationMinutes INTEGER NOT NULL,
  startTime INTEGER NOT NULL,      -- epoch seconds
  endTime INTEGER,                 -- epoch seconds or NULL while active
  completed INTEGER NOT NULL DEFAULT 0,
  gaveUp INTEGER NOT NULL DEFAULT 0,
  xpGained INTEGER NOT NULL DEFAULT 0,
  goldGained INTEGER NOT NULL DEFAULT 0,
  serverValidated INTEGER NOT NULL DEFAULT 0,

  -- Reward ledger snapshot (frozen allocation totals + metadata)
  ledgerVersion INTEGER,           -- null until frozen; set to 1 currently
  ledgerHash TEXT,
  ledgerTotalXp INTEGER,
  ledgerTotalGold INTEGER,

  createdAt INTEGER NOT NULL,      -- epoch seconds (usually = startTime)

  FOREIGN KEY (heroId) REFERENCES HeroEntity(id)
);

-- Helpful indexes
CREATE INDEX IF NOT EXISTS idx_questlog_hero       ON QuestLogEntity(heroId);
CREATE INDEX IF NOT EXISTS idx_questlog_hero_start ON QuestLogEntity(heroId, startTime);

-- Enforce at most one active quest globally
CREATE UNIQUE INDEX IF NOT EXISTS idx_one_active_quest
ON QuestLogEntity ((CASE WHEN endTime IS NULL AND gaveUp = 0 THEN 1 END))
WHERE endTime IS NULL AND gaveUp = 0;

-- ---------------------------------------------------------------------
-- Core queries used throughout the app
-- ---------------------------------------------------------------------

selectQuestsByHero:
SELECT * FROM QuestLogEntity
WHERE heroId = ?
ORDER BY createdAt DESC;

selectRecentQuests:
SELECT * FROM QuestLogEntity
WHERE heroId = ?
ORDER BY createdAt DESC
LIMIT ?;

-- (Optional) direct date-range query by startTime
selectQuestsByHeroAndStartBetween:
SELECT * FROM QuestLogEntity
WHERE heroId = ?
  AND startTime BETWEEN ? AND ?
ORDER BY startTime DESC;

-- Global helpers: "active quest" (no end, not given up)
selectActiveQuestGlobal:
SELECT * FROM QuestLogEntity
WHERE endTime IS NULL AND gaveUp = 0
ORDER BY startTime DESC
LIMIT 1;

selectActiveQuestsGlobal:
SELECT * FROM QuestLogEntity
WHERE endTime IS NULL AND gaveUp = 0
ORDER BY startTime DESC;

insertQuest:
INSERT INTO QuestLogEntity (
  id, heroId, durationMinutes, startTime, endTime, completed, gaveUp,
  xpGained, goldGained, serverValidated,
  ledgerVersion, ledgerHash, ledgerTotalXp, ledgerTotalGold,
  createdAt
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

updateQuestCompletion:
UPDATE QuestLogEntity
SET endTime = ?, completed = ?, xpGained = ?, goldGained = ?, serverValidated = ?
WHERE id = ?;

updateQuestGaveUp:
UPDATE QuestLogEntity
SET endTime = ?, completed = 0, gaveUp = 1, xpGained = 0, goldGained = 0, serverValidated = 0
WHERE id = ?;

-- Reward ledger snapshot helpers
updateLedgerSnapshot:
UPDATE QuestLogEntity
SET ledgerVersion = ?, ledgerHash = ?, ledgerTotalXp = ?, ledgerTotalGold = ?
WHERE id = ?;

selectLedgerSnapshot:
SELECT ledgerVersion, ledgerHash, ledgerTotalXp, ledgerTotalGold
FROM QuestLogEntity
WHERE id = ?;

-- ---------------------------------------------------------------------
-- Lifetime aggregates (for the Hero Stats screen)
-- ---------------------------------------------------------------------

sumMinutesByHero:
SELECT COALESCE(SUM(durationMinutes), 0) AS total_minutes
FROM QuestLogEntity
WHERE heroId = ?;

countQuestsByHero:
SELECT COUNT(*) AS total_quests
FROM QuestLogEntity
WHERE heroId = ?;

maxSessionByHero:
SELECT COALESCE(MAX(durationMinutes), 0) AS longest_session
FROM QuestLogEntity
WHERE heroId = ?;

-- Distinct days with at least one quest (epoch-day = startTime / 86400)
selectEventDaysEpochByHero:
SELECT DISTINCT (startTime / 86400) AS epoch_day
FROM QuestLogEntity
WHERE heroId = ?
ORDER BY epoch_day ASC;

-- Optional metric: >0 only if such events exist
countCleansesByHero:
SELECT COUNT(*) AS cleansed
FROM QuestEventEntity e
JOIN QuestLogEntity q ON e.questId = q.id
WHERE q.heroId = ?
  AND e.type = 'CURSE_CLEANSED';
